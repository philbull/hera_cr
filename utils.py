#!/usr/bin/env python
"""
Helper functions to measure things like noise covariances from data files.
"""
import numpy as np

#../hera_data/zen.2458042.14789.xx.HH.uvOR_0_1.npz

def load_hera_data(fname):
    """
    Load data and RFI flags from a pre-processed numpy file generated by 
    hera_extract_data.py.
    """
    dat = np.load(fname)
    return dat['d'], dat['w']


def estimate_noise_cov(d, w):
    """
    Estimate frequency-frequency noise covariance by performing finite 
    differences on the data in the time direction and then averaging.
    
    Currently assumes a diagonal noise covariance. The real and imaginary noise 
    covariances are estimated separately. The results are turned into a smooth 
    function by fitting a Chebyshev polynomial.
    """
    # Create masked array
    #mask = np.logical_not( w.astype(bool) )
    mask = np.logical_not( w.astype(bool) )
    d_masked = np.ma.array(d, mask=mask)
    
    # Difference masked array in the time direction. Assuming that the signal 
    # is almost constant between neighbouring time samples, these values should 
    # essentially be the difference of the noise in neighbouring time samples
    diff_d = np.ma.diff(d_masked, axis=0)
    #sigma = np.std(diff_d, axis=0)
    idxs = np.where(np.abs(diff_d) < 0.1)
    sigma = np.std(diff_d[idxs].real)
    
    idxs = np.where(np.abs(diff_d.imag) < 0.1)
    sigma_i = np.std(diff_d[idxs].imag)
    print diff_d
    print sigma, sigma_i
    
    P.hist(diff_d.flatten(), bins=100, range=(-0.2, 0.2), normed=True)
    xx = np.linspace(-0.1, 0.1, 500)
    P.plot(xx, np.exp(-0.5*(xx/sigma)**2.)/np.sqrt(2.*np.pi)/sigma, 'r-', lw=1.8)
    P.show()
    
    return sigma, np.std(diff_d.real, axis=0), np.std(diff_d.imag, axis=0)
    
    sqrtNr
    ch = np.polynomial.chebyshev.chebfit(x, avg_r2, deg=18, w=ww2)



#d, w = load_hera_data("../hera_data/zen.2458042.14789.xx.HH.uvOR_0_1.npz")

